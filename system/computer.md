https://web.archive.org/web/20090124133914/http://www.eden-study.org/articles/2007/problems-ontology-programs_ao.pdf

内存:用于存储信息的设备
图灵机:将程序(指令和数据)存储在内存上
编程图灵机:各种高级语言,它们被设计成,能编译成图灵机
图灵完备性:一个数据操作规则系统可用于模拟任何图灵机
> 图灵完备性够识别或决定其他数据操作规则集
冯诺依曼架构:
> 包含算术逻辑单元和处理器寄存器的处理单元
> 包含指令寄存器和程序计数器的控制单元
> 存储数据和指令的内存
> 外部大容量存储器
> 输入和输出机制

* L表示程序的集合
* T表示图灵机的集合,则$
\forall t\in T,
\exist l\in L,l在t上$

* CT表达图灵完备性的集合,则$
\forall ct\in \mathbb{CT},\exist l_t\in L,\forall t\in T,ct(l_t)\rightarrow t$

* 编译器:$\forall c\in C,\exist L\in \mathbb{L},T_c\in \mathbb{T} ,\forall l \in L,闭包\overline{c(l)}=T_c$
> 记$\bar{c}为C_L,L为L_c$


* 格式良好的表达式: 
  $ e\in L,\exist c \in C_L,c(e)\in T_c $

* encapsulation (数据抽象或封装)

$$
Modules =\{Stack\} \\
Procedures =\{Stack.push, Stack.pop, Stack.peek\} \\
Member = \{(Stack.push,Stack), ... (Stack.peek,Stack)\} \\
Private=\{\} \\
Invoke=\{\} \\
∀x,m,p • Private(p)∧Member(p,m)∧¬Member(x,m)⇒¬Invoke(x,p) 
$$


---

## Question


1. 通过抽象的解析的系统应用,可以将程序与元程序和硬件区分开来.
对程序抽象的细化,会导致分类:
    1.程序过程和程序脚本的区别,(包括源代码和机器代码)
    ~~详尽的意思是它解释了我们所描述的所有程序，包括~~
    1. 统一了程序与元程序和硬件,作为根目录
    2. 统一了所有的差异都是对抽象概念的解释;
    3. 在某种程度上是确定的，所有的差别都是明确的，其中一些用数学逻辑表示。

我们检查了两个示例程序脚本的本体论承诺，从中得到结论如下:

2. 用编程语言$L$编码的程序脚本$S_L$，如果满足以下条件，则显然属于编程范式P提供的本体.
    1. 编程语言L承诺编程范式P
    2. 程序脚本$S_L$是P的元程序的具体化
> $S_L impl \oplus P,S_L is impl_{\oplus P}, L \subset impl_P$

我们对语言合成的研究,特别是合成一个编译器的过程中,我们得出了以下问题的答案:

3. 的编程语言是通过将一组特定的元程序具体化而形成的。编程语言的激增可以用,可能的元程序子集的激增来解释.
可供选择的元程序实体的，每一个具体的组合,都最终产生了一种不同的语言.
    我们提出的问题和我们研究的答案只是更大计划的第一步,研究计算机程序的本体。我们研究了一些争论的细节,我们把它略去了，它的提法已经略去了。具体实例分析.为了证实所提出的答案，尽管进一步的研究必须证明证据

我们进一步观察下列未决问题:
4. 虽然程序过程是无形的，但它们仍然是因果对象:它们会移动在电脑屏幕上制作图片和操作机器。
无形对象怎么才是因果对象?这个问题是否是一种逻辑上的问题?

5. 是否有任何抽象的解释来说明(A-I到A-V)是等价的?例如，我们能否将泛化(A-II)与欠规范(A-III)区分开来?

6. 软件设计规范和其他元程序之间的区别是什么?

这与功能性规范和非功能性规范之间的区别有关系吗?
是否这两个这个区别,提供了 metaProgram 的子目录.

7. 战略陈述、战术陈述和实现陈述(§3.4)之间的区别是否提供了一个
对metaProgram的分解?
8. 局部性标准[4]能否作为抽象的一种解释而被表述出来?
9. 元程序的语言(“规范语言”)与编程语言的区别是什么?编程语言和硬件规范语言之间的区别是什么?
10. 编程范式是否可以完全公理化，使其本体显式?
11. 程式的识别标准是什么?程序脚本和程序过程之间到底有什么区别?这是一个句法、语义还是另一个标准?